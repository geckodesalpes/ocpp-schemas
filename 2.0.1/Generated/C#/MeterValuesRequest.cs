// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using Ocpp._201.Generated.Models.MeterValuesRequest;
//
//    var meterValuesRequest = MeterValuesRequest.FromJson(jsonString);

namespace Ocpp._201.Generated.Models.MeterValuesRequest
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    /// <summary>
    /// Request_ Body
    /// urn:x-enexis:ecdm:uid:2:234744
    /// </summary>
    public partial class MeterValuesRequest
    {
        [JsonProperty("customData", NullValueHandling = NullValueHandling.Ignore)]
        public virtual CustomDataType CustomData { get; set; }

        /// <summary>
        /// Request_ Body. EVSEID. Numeric_ Identifier
        /// urn:x-enexis:ecdm:uid:1:571101
        /// This contains a number (&gt;0) designating an EVSE of the Charging Station. ‘0’ (zero) is
        /// used to designate the main power meter.
        /// </summary>
        [JsonProperty("evseId")]
        public virtual long EvseId { get; set; }

        [JsonProperty("meterValue")]
        public virtual System.Collections.Generic.List<MeterValueType> MeterValue { get; set; }
    }

    /// <summary>
    /// This class does not get 'AdditionalProperties = false' in the schema generation, so it
    /// can be extended with arbitrary JSON properties to allow adding custom data.
    /// </summary>
    public partial class CustomDataType
    {
        [JsonProperty("vendorId")]
        [JsonConverter(typeof(PurpleMinMaxLengthCheckConverter))]
        public virtual string VendorId { get; set; }
    }

    /// <summary>
    /// Meter_ Value
    /// urn:x-oca:ocpp:uid:2:233265
    /// Collection of one or more sampled values in MeterValuesRequest and TransactionEvent. All
    /// sampled values in a MeterValue are sampled at the same point in time.
    /// </summary>
    public partial class MeterValueType
    {
        [JsonProperty("customData", NullValueHandling = NullValueHandling.Ignore)]
        public virtual CustomDataType CustomData { get; set; }

        [JsonProperty("sampledValue")]
        public virtual System.Collections.Generic.List<SampledValueType> SampledValue { get; set; }

        /// <summary>
        /// Meter_ Value. Timestamp. Date_ Time
        /// urn:x-oca:ocpp:uid:1:569259
        /// Timestamp for measured value(s).
        /// </summary>
        [JsonProperty("timestamp")]
        public virtual DateTimeOffset Timestamp { get; set; }
    }

    /// <summary>
    /// Sampled_ Value
    /// urn:x-oca:ocpp:uid:2:233266
    /// Single sampled value in MeterValues. Each value can be accompanied by optional fields.
    ///
    /// To save on mobile data usage, default values of all of the optional fields are such that.
    /// The value without any additional fields will be interpreted, as a register reading of
    /// active import energy in Wh (Watt-hour) units.
    /// </summary>
    public partial class SampledValueType
    {
        [JsonProperty("context", NullValueHandling = NullValueHandling.Ignore)]
        public virtual ReadingContextEnumType? Context { get; set; }

        [JsonProperty("customData", NullValueHandling = NullValueHandling.Ignore)]
        public virtual CustomDataType CustomData { get; set; }

        [JsonProperty("location", NullValueHandling = NullValueHandling.Ignore)]
        public virtual LocationEnumType? Location { get; set; }

        [JsonProperty("measurand", NullValueHandling = NullValueHandling.Ignore)]
        public virtual MeasurandEnumType? Measurand { get; set; }

        [JsonProperty("phase", NullValueHandling = NullValueHandling.Ignore)]
        public virtual PhaseEnumType? Phase { get; set; }

        [JsonProperty("signedMeterValue", NullValueHandling = NullValueHandling.Ignore)]
        public virtual SignedMeterValueType SignedMeterValue { get; set; }

        [JsonProperty("unitOfMeasure", NullValueHandling = NullValueHandling.Ignore)]
        public virtual UnitOfMeasureType UnitOfMeasure { get; set; }

        /// <summary>
        /// Sampled_ Value. Value. Measure
        /// urn:x-oca:ocpp:uid:1:569260
        /// Indicates the measured value.
        /// </summary>
        [JsonProperty("value")]
        public virtual double Value { get; set; }
    }

    /// <summary>
    /// Represent a signed version of the meter value.
    /// </summary>
    public partial class SignedMeterValueType
    {
        [JsonProperty("customData", NullValueHandling = NullValueHandling.Ignore)]
        public virtual CustomDataType CustomData { get; set; }

        /// <summary>
        /// Method used to encode the meter values before applying the digital signature algorithm.
        /// </summary>
        [JsonProperty("encodingMethod")]
        [JsonConverter(typeof(FluffyMinMaxLengthCheckConverter))]
        public virtual string EncodingMethod { get; set; }

        /// <summary>
        /// Base64 encoded, sending depends on configuration variable _PublicKeyWithSignedMeterValue_.
        /// </summary>
        [JsonProperty("publicKey")]
        [JsonConverter(typeof(TentacledMinMaxLengthCheckConverter))]
        public virtual string PublicKey { get; set; }

        /// <summary>
        /// Base64 encoded, contains the signed data which might contain more then just the meter
        /// value. It can contain information like timestamps, reference to a customer etc.
        /// </summary>
        [JsonProperty("signedMeterData")]
        [JsonConverter(typeof(TentacledMinMaxLengthCheckConverter))]
        public virtual string SignedMeterData { get; set; }

        /// <summary>
        /// Method used to create the digital signature.
        /// </summary>
        [JsonProperty("signingMethod")]
        [JsonConverter(typeof(FluffyMinMaxLengthCheckConverter))]
        public virtual string SigningMethod { get; set; }
    }

    /// <summary>
    /// Represents a UnitOfMeasure with a multiplier
    /// </summary>
    public partial class UnitOfMeasureType
    {
        [JsonProperty("customData", NullValueHandling = NullValueHandling.Ignore)]
        public virtual CustomDataType CustomData { get; set; }

        /// <summary>
        /// Multiplier, this value represents the exponent to base 10. I.e. multiplier 3 means 10
        /// raised to the 3rd power. Default is 0.
        /// </summary>
        [JsonProperty("multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public virtual long? Multiplier { get; set; }

        /// <summary>
        /// Unit of the value. Default = "Wh" if the (default) measurand is an "Energy" type.
        /// This field SHALL use a value from the list Standardized Units of Measurements in Part 2
        /// Appendices.
        /// If an applicable unit is available in that list, otherwise a "custom" unit might be used.
        /// </summary>
        [JsonProperty("unit", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(StickyMinMaxLengthCheckConverter))]
        public virtual string Unit { get; set; }
    }

    /// <summary>
    /// Sampled_ Value. Context. Reading_ Context_ Code
    /// urn:x-oca:ocpp:uid:1:569261
    /// Type of detail value: start, end or sample. Default = "Sample.Periodic"
    /// </summary>
    public enum ReadingContextEnumType { InterruptionBegin, InterruptionEnd, Other, SampleClock, SamplePeriodic, TransactionBegin, TransactionEnd, Trigger };

    /// <summary>
    /// Sampled_ Value. Location. Location_ Code
    /// urn:x-oca:ocpp:uid:1:569265
    /// Indicates where the measured value has been sampled. Default =  "Outlet"
    /// </summary>
    public enum LocationEnumType { Body, Cable, Ev, Inlet, Outlet };

    /// <summary>
    /// Sampled_ Value. Measurand. Measurand_ Code
    /// urn:x-oca:ocpp:uid:1:569263
    /// Type of measurement. Default = "Energy.Active.Import.Register"
    /// </summary>
    public enum MeasurandEnumType { CurrentExport, CurrentImport, CurrentOffered, EnergyActiveExportInterval, EnergyActiveExportRegister, EnergyActiveImportInterval, EnergyActiveImportRegister, EnergyActiveNet, EnergyApparentExport, EnergyApparentImport, EnergyApparentNet, EnergyReactiveExportInterval, EnergyReactiveExportRegister, EnergyReactiveImportInterval, EnergyReactiveImportRegister, EnergyReactiveNet, Frequency, PowerActiveExport, PowerActiveImport, PowerFactor, PowerOffered, PowerReactiveExport, PowerReactiveImport, SoC, Voltage };

    /// <summary>
    /// Sampled_ Value. Phase. Phase_ Code
    /// urn:x-oca:ocpp:uid:1:569264
    /// Indicates how the measured value is to be interpreted. For instance between L1 and
    /// neutral (L1-N) Please note that not all values of phase are applicable to all Measurands.
    /// When phase is absent, the measured value is interpreted as an overall value.
    /// </summary>
    public enum PhaseEnumType { L1, L1L2, L1N, L2, L2L3, L2N, L3, L3L1, L3N, N };

    public partial class MeterValuesRequest
    {
        public static MeterValuesRequest FromJson(string json) => JsonConvert.DeserializeObject<MeterValuesRequest>(json, Ocpp._201.Generated.Models.MeterValuesRequest.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this MeterValuesRequest self) => JsonConvert.SerializeObject(self, Ocpp._201.Generated.Models.MeterValuesRequest.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                ReadingContextEnumTypeConverter.Singleton,
                LocationEnumTypeConverter.Singleton,
                MeasurandEnumTypeConverter.Singleton,
                PhaseEnumTypeConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class PurpleMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length <= 255)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length <= 255)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly PurpleMinMaxLengthCheckConverter Singleton = new PurpleMinMaxLengthCheckConverter();
    }

    internal class ReadingContextEnumTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ReadingContextEnumType) || t == typeof(ReadingContextEnumType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Interruption.Begin":
                    return ReadingContextEnumType.InterruptionBegin;
                case "Interruption.End":
                    return ReadingContextEnumType.InterruptionEnd;
                case "Other":
                    return ReadingContextEnumType.Other;
                case "Sample.Clock":
                    return ReadingContextEnumType.SampleClock;
                case "Sample.Periodic":
                    return ReadingContextEnumType.SamplePeriodic;
                case "Transaction.Begin":
                    return ReadingContextEnumType.TransactionBegin;
                case "Transaction.End":
                    return ReadingContextEnumType.TransactionEnd;
                case "Trigger":
                    return ReadingContextEnumType.Trigger;
            }
            throw new Exception("Cannot unmarshal type ReadingContextEnumType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ReadingContextEnumType)untypedValue;
            switch (value)
            {
                case ReadingContextEnumType.InterruptionBegin:
                    serializer.Serialize(writer, "Interruption.Begin");
                    return;
                case ReadingContextEnumType.InterruptionEnd:
                    serializer.Serialize(writer, "Interruption.End");
                    return;
                case ReadingContextEnumType.Other:
                    serializer.Serialize(writer, "Other");
                    return;
                case ReadingContextEnumType.SampleClock:
                    serializer.Serialize(writer, "Sample.Clock");
                    return;
                case ReadingContextEnumType.SamplePeriodic:
                    serializer.Serialize(writer, "Sample.Periodic");
                    return;
                case ReadingContextEnumType.TransactionBegin:
                    serializer.Serialize(writer, "Transaction.Begin");
                    return;
                case ReadingContextEnumType.TransactionEnd:
                    serializer.Serialize(writer, "Transaction.End");
                    return;
                case ReadingContextEnumType.Trigger:
                    serializer.Serialize(writer, "Trigger");
                    return;
            }
            throw new Exception("Cannot marshal type ReadingContextEnumType");
        }

        public static readonly ReadingContextEnumTypeConverter Singleton = new ReadingContextEnumTypeConverter();
    }

    internal class LocationEnumTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(LocationEnumType) || t == typeof(LocationEnumType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Body":
                    return LocationEnumType.Body;
                case "Cable":
                    return LocationEnumType.Cable;
                case "EV":
                    return LocationEnumType.Ev;
                case "Inlet":
                    return LocationEnumType.Inlet;
                case "Outlet":
                    return LocationEnumType.Outlet;
            }
            throw new Exception("Cannot unmarshal type LocationEnumType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (LocationEnumType)untypedValue;
            switch (value)
            {
                case LocationEnumType.Body:
                    serializer.Serialize(writer, "Body");
                    return;
                case LocationEnumType.Cable:
                    serializer.Serialize(writer, "Cable");
                    return;
                case LocationEnumType.Ev:
                    serializer.Serialize(writer, "EV");
                    return;
                case LocationEnumType.Inlet:
                    serializer.Serialize(writer, "Inlet");
                    return;
                case LocationEnumType.Outlet:
                    serializer.Serialize(writer, "Outlet");
                    return;
            }
            throw new Exception("Cannot marshal type LocationEnumType");
        }

        public static readonly LocationEnumTypeConverter Singleton = new LocationEnumTypeConverter();
    }

    internal class MeasurandEnumTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(MeasurandEnumType) || t == typeof(MeasurandEnumType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Current.Export":
                    return MeasurandEnumType.CurrentExport;
                case "Current.Import":
                    return MeasurandEnumType.CurrentImport;
                case "Current.Offered":
                    return MeasurandEnumType.CurrentOffered;
                case "Energy.Active.Export.Interval":
                    return MeasurandEnumType.EnergyActiveExportInterval;
                case "Energy.Active.Export.Register":
                    return MeasurandEnumType.EnergyActiveExportRegister;
                case "Energy.Active.Import.Interval":
                    return MeasurandEnumType.EnergyActiveImportInterval;
                case "Energy.Active.Import.Register":
                    return MeasurandEnumType.EnergyActiveImportRegister;
                case "Energy.Active.Net":
                    return MeasurandEnumType.EnergyActiveNet;
                case "Energy.Apparent.Export":
                    return MeasurandEnumType.EnergyApparentExport;
                case "Energy.Apparent.Import":
                    return MeasurandEnumType.EnergyApparentImport;
                case "Energy.Apparent.Net":
                    return MeasurandEnumType.EnergyApparentNet;
                case "Energy.Reactive.Export.Interval":
                    return MeasurandEnumType.EnergyReactiveExportInterval;
                case "Energy.Reactive.Export.Register":
                    return MeasurandEnumType.EnergyReactiveExportRegister;
                case "Energy.Reactive.Import.Interval":
                    return MeasurandEnumType.EnergyReactiveImportInterval;
                case "Energy.Reactive.Import.Register":
                    return MeasurandEnumType.EnergyReactiveImportRegister;
                case "Energy.Reactive.Net":
                    return MeasurandEnumType.EnergyReactiveNet;
                case "Frequency":
                    return MeasurandEnumType.Frequency;
                case "Power.Active.Export":
                    return MeasurandEnumType.PowerActiveExport;
                case "Power.Active.Import":
                    return MeasurandEnumType.PowerActiveImport;
                case "Power.Factor":
                    return MeasurandEnumType.PowerFactor;
                case "Power.Offered":
                    return MeasurandEnumType.PowerOffered;
                case "Power.Reactive.Export":
                    return MeasurandEnumType.PowerReactiveExport;
                case "Power.Reactive.Import":
                    return MeasurandEnumType.PowerReactiveImport;
                case "SoC":
                    return MeasurandEnumType.SoC;
                case "Voltage":
                    return MeasurandEnumType.Voltage;
            }
            throw new Exception("Cannot unmarshal type MeasurandEnumType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (MeasurandEnumType)untypedValue;
            switch (value)
            {
                case MeasurandEnumType.CurrentExport:
                    serializer.Serialize(writer, "Current.Export");
                    return;
                case MeasurandEnumType.CurrentImport:
                    serializer.Serialize(writer, "Current.Import");
                    return;
                case MeasurandEnumType.CurrentOffered:
                    serializer.Serialize(writer, "Current.Offered");
                    return;
                case MeasurandEnumType.EnergyActiveExportInterval:
                    serializer.Serialize(writer, "Energy.Active.Export.Interval");
                    return;
                case MeasurandEnumType.EnergyActiveExportRegister:
                    serializer.Serialize(writer, "Energy.Active.Export.Register");
                    return;
                case MeasurandEnumType.EnergyActiveImportInterval:
                    serializer.Serialize(writer, "Energy.Active.Import.Interval");
                    return;
                case MeasurandEnumType.EnergyActiveImportRegister:
                    serializer.Serialize(writer, "Energy.Active.Import.Register");
                    return;
                case MeasurandEnumType.EnergyActiveNet:
                    serializer.Serialize(writer, "Energy.Active.Net");
                    return;
                case MeasurandEnumType.EnergyApparentExport:
                    serializer.Serialize(writer, "Energy.Apparent.Export");
                    return;
                case MeasurandEnumType.EnergyApparentImport:
                    serializer.Serialize(writer, "Energy.Apparent.Import");
                    return;
                case MeasurandEnumType.EnergyApparentNet:
                    serializer.Serialize(writer, "Energy.Apparent.Net");
                    return;
                case MeasurandEnumType.EnergyReactiveExportInterval:
                    serializer.Serialize(writer, "Energy.Reactive.Export.Interval");
                    return;
                case MeasurandEnumType.EnergyReactiveExportRegister:
                    serializer.Serialize(writer, "Energy.Reactive.Export.Register");
                    return;
                case MeasurandEnumType.EnergyReactiveImportInterval:
                    serializer.Serialize(writer, "Energy.Reactive.Import.Interval");
                    return;
                case MeasurandEnumType.EnergyReactiveImportRegister:
                    serializer.Serialize(writer, "Energy.Reactive.Import.Register");
                    return;
                case MeasurandEnumType.EnergyReactiveNet:
                    serializer.Serialize(writer, "Energy.Reactive.Net");
                    return;
                case MeasurandEnumType.Frequency:
                    serializer.Serialize(writer, "Frequency");
                    return;
                case MeasurandEnumType.PowerActiveExport:
                    serializer.Serialize(writer, "Power.Active.Export");
                    return;
                case MeasurandEnumType.PowerActiveImport:
                    serializer.Serialize(writer, "Power.Active.Import");
                    return;
                case MeasurandEnumType.PowerFactor:
                    serializer.Serialize(writer, "Power.Factor");
                    return;
                case MeasurandEnumType.PowerOffered:
                    serializer.Serialize(writer, "Power.Offered");
                    return;
                case MeasurandEnumType.PowerReactiveExport:
                    serializer.Serialize(writer, "Power.Reactive.Export");
                    return;
                case MeasurandEnumType.PowerReactiveImport:
                    serializer.Serialize(writer, "Power.Reactive.Import");
                    return;
                case MeasurandEnumType.SoC:
                    serializer.Serialize(writer, "SoC");
                    return;
                case MeasurandEnumType.Voltage:
                    serializer.Serialize(writer, "Voltage");
                    return;
            }
            throw new Exception("Cannot marshal type MeasurandEnumType");
        }

        public static readonly MeasurandEnumTypeConverter Singleton = new MeasurandEnumTypeConverter();
    }

    internal class PhaseEnumTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PhaseEnumType) || t == typeof(PhaseEnumType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "L1":
                    return PhaseEnumType.L1;
                case "L1-L2":
                    return PhaseEnumType.L1L2;
                case "L1-N":
                    return PhaseEnumType.L1N;
                case "L2":
                    return PhaseEnumType.L2;
                case "L2-L3":
                    return PhaseEnumType.L2L3;
                case "L2-N":
                    return PhaseEnumType.L2N;
                case "L3":
                    return PhaseEnumType.L3;
                case "L3-L1":
                    return PhaseEnumType.L3L1;
                case "L3-N":
                    return PhaseEnumType.L3N;
                case "N":
                    return PhaseEnumType.N;
            }
            throw new Exception("Cannot unmarshal type PhaseEnumType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PhaseEnumType)untypedValue;
            switch (value)
            {
                case PhaseEnumType.L1:
                    serializer.Serialize(writer, "L1");
                    return;
                case PhaseEnumType.L1L2:
                    serializer.Serialize(writer, "L1-L2");
                    return;
                case PhaseEnumType.L1N:
                    serializer.Serialize(writer, "L1-N");
                    return;
                case PhaseEnumType.L2:
                    serializer.Serialize(writer, "L2");
                    return;
                case PhaseEnumType.L2L3:
                    serializer.Serialize(writer, "L2-L3");
                    return;
                case PhaseEnumType.L2N:
                    serializer.Serialize(writer, "L2-N");
                    return;
                case PhaseEnumType.L3:
                    serializer.Serialize(writer, "L3");
                    return;
                case PhaseEnumType.L3L1:
                    serializer.Serialize(writer, "L3-L1");
                    return;
                case PhaseEnumType.L3N:
                    serializer.Serialize(writer, "L3-N");
                    return;
                case PhaseEnumType.N:
                    serializer.Serialize(writer, "N");
                    return;
            }
            throw new Exception("Cannot marshal type PhaseEnumType");
        }

        public static readonly PhaseEnumTypeConverter Singleton = new PhaseEnumTypeConverter();
    }

    internal class FluffyMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length <= 50)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length <= 50)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly FluffyMinMaxLengthCheckConverter Singleton = new FluffyMinMaxLengthCheckConverter();
    }

    internal class TentacledMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length <= 2500)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length <= 2500)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly TentacledMinMaxLengthCheckConverter Singleton = new TentacledMinMaxLengthCheckConverter();
    }

    internal class StickyMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length <= 20)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length <= 20)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly StickyMinMaxLengthCheckConverter Singleton = new StickyMinMaxLengthCheckConverter();
    }
}
