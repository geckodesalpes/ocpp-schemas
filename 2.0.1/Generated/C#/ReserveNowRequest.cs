// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using Ocpp._201.Generated.Models.ReserveNowRequest;
//
//    var reserveNowRequest = ReserveNowRequest.FromJson(jsonString);

namespace Ocpp._201.Generated.Models.ReserveNowRequest
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class ReserveNowRequest
    {
        [JsonProperty("connectorType", NullValueHandling = NullValueHandling.Ignore)]
        public virtual ConnectorEnumType? ConnectorType { get; set; }

        [JsonProperty("customData", NullValueHandling = NullValueHandling.Ignore)]
        public virtual CustomDataType CustomData { get; set; }

        /// <summary>
        /// This contains ID of the evse to be reserved.
        /// </summary>
        [JsonProperty("evseId", NullValueHandling = NullValueHandling.Ignore)]
        public virtual long? EvseId { get; set; }

        /// <summary>
        /// Date and time at which the reservation expires.
        /// </summary>
        [JsonProperty("expiryDateTime")]
        public virtual DateTimeOffset ExpiryDateTime { get; set; }

        [JsonProperty("groupIdToken", NullValueHandling = NullValueHandling.Ignore)]
        public virtual IdTokenType GroupIdToken { get; set; }

        /// <summary>
        /// Id of reservation.
        /// </summary>
        [JsonProperty("id")]
        public virtual long Id { get; set; }

        [JsonProperty("idToken")]
        public virtual IdTokenType IdToken { get; set; }
    }

    /// <summary>
    /// This class does not get 'AdditionalProperties = false' in the schema generation, so it
    /// can be extended with arbitrary JSON properties to allow adding custom data.
    /// </summary>
    public partial class CustomDataType
    {
        [JsonProperty("vendorId")]
        [JsonConverter(typeof(PurpleMinMaxLengthCheckConverter))]
        public virtual string VendorId { get; set; }
    }

    /// <summary>
    /// Contains a case insensitive identifier to use for the authorization and the type of
    /// authorization to support multiple forms of identifiers.
    /// </summary>
    public partial class IdTokenType
    {
        [JsonProperty("additionalInfo", NullValueHandling = NullValueHandling.Ignore)]
        public virtual System.Collections.Generic.List<AdditionalInfoType> AdditionalInfo { get; set; }

        [JsonProperty("customData", NullValueHandling = NullValueHandling.Ignore)]
        public virtual CustomDataType CustomData { get; set; }

        /// <summary>
        /// IdToken is case insensitive. Might hold the hidden id of an RFID tag, but can for example
        /// also contain a UUID.
        /// </summary>
        [JsonProperty("idToken")]
        [JsonConverter(typeof(FluffyMinMaxLengthCheckConverter))]
        public virtual string IdToken { get; set; }

        [JsonProperty("type")]
        public virtual IdTokenEnumType Type { get; set; }
    }

    /// <summary>
    /// Contains a case insensitive identifier to use for the authorization and the type of
    /// authorization to support multiple forms of identifiers.
    /// </summary>
    public partial class AdditionalInfoType
    {
        /// <summary>
        /// This field specifies the additional IdToken.
        /// </summary>
        [JsonProperty("additionalIdToken")]
        [JsonConverter(typeof(FluffyMinMaxLengthCheckConverter))]
        public virtual string AdditionalIdToken { get; set; }

        [JsonProperty("customData", NullValueHandling = NullValueHandling.Ignore)]
        public virtual CustomDataType CustomData { get; set; }

        /// <summary>
        /// This defines the type of the additionalIdToken. This is a custom type, so the
        /// implementation needs to be agreed upon by all involved parties.
        /// </summary>
        [JsonProperty("type")]
        [JsonConverter(typeof(TentacledMinMaxLengthCheckConverter))]
        public virtual string Type { get; set; }
    }

    /// <summary>
    /// This field specifies the connector type.
    /// </summary>
    public enum ConnectorEnumType { CCcs1, CCcs2, CG105, CTesla, CType1, CType2, Other1PhMax16A, Other1PhOver16A, Other3Ph, Pan, S3091P16A, S3091P32A, S3093P16A, S3093P32A, SBs1361, SCee77, SType2, SType3, Undetermined, Unknown, WInductive, WResonant };

    /// <summary>
    /// Enumeration of possible idToken types.
    /// </summary>
    public enum IdTokenEnumType { Central, EMaid, Iso14443, Iso15693, KeyCode, Local, MacAddress, NoAuthorization };

    public partial class ReserveNowRequest
    {
        public static ReserveNowRequest FromJson(string json) => JsonConvert.DeserializeObject<ReserveNowRequest>(json, Ocpp._201.Generated.Models.ReserveNowRequest.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this ReserveNowRequest self) => JsonConvert.SerializeObject(self, Ocpp._201.Generated.Models.ReserveNowRequest.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                ConnectorEnumTypeConverter.Singleton,
                IdTokenEnumTypeConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class ConnectorEnumTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ConnectorEnumType) || t == typeof(ConnectorEnumType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Other1PhMax16A":
                    return ConnectorEnumType.Other1PhMax16A;
                case "Other1PhOver16A":
                    return ConnectorEnumType.Other1PhOver16A;
                case "Other3Ph":
                    return ConnectorEnumType.Other3Ph;
                case "Pan":
                    return ConnectorEnumType.Pan;
                case "Undetermined":
                    return ConnectorEnumType.Undetermined;
                case "Unknown":
                    return ConnectorEnumType.Unknown;
                case "cCCS1":
                    return ConnectorEnumType.CCcs1;
                case "cCCS2":
                    return ConnectorEnumType.CCcs2;
                case "cG105":
                    return ConnectorEnumType.CG105;
                case "cTesla":
                    return ConnectorEnumType.CTesla;
                case "cType1":
                    return ConnectorEnumType.CType1;
                case "cType2":
                    return ConnectorEnumType.CType2;
                case "s309-1P-16A":
                    return ConnectorEnumType.S3091P16A;
                case "s309-1P-32A":
                    return ConnectorEnumType.S3091P32A;
                case "s309-3P-16A":
                    return ConnectorEnumType.S3093P16A;
                case "s309-3P-32A":
                    return ConnectorEnumType.S3093P32A;
                case "sBS1361":
                    return ConnectorEnumType.SBs1361;
                case "sCEE-7-7":
                    return ConnectorEnumType.SCee77;
                case "sType2":
                    return ConnectorEnumType.SType2;
                case "sType3":
                    return ConnectorEnumType.SType3;
                case "wInductive":
                    return ConnectorEnumType.WInductive;
                case "wResonant":
                    return ConnectorEnumType.WResonant;
            }
            throw new Exception("Cannot unmarshal type ConnectorEnumType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ConnectorEnumType)untypedValue;
            switch (value)
            {
                case ConnectorEnumType.Other1PhMax16A:
                    serializer.Serialize(writer, "Other1PhMax16A");
                    return;
                case ConnectorEnumType.Other1PhOver16A:
                    serializer.Serialize(writer, "Other1PhOver16A");
                    return;
                case ConnectorEnumType.Other3Ph:
                    serializer.Serialize(writer, "Other3Ph");
                    return;
                case ConnectorEnumType.Pan:
                    serializer.Serialize(writer, "Pan");
                    return;
                case ConnectorEnumType.Undetermined:
                    serializer.Serialize(writer, "Undetermined");
                    return;
                case ConnectorEnumType.Unknown:
                    serializer.Serialize(writer, "Unknown");
                    return;
                case ConnectorEnumType.CCcs1:
                    serializer.Serialize(writer, "cCCS1");
                    return;
                case ConnectorEnumType.CCcs2:
                    serializer.Serialize(writer, "cCCS2");
                    return;
                case ConnectorEnumType.CG105:
                    serializer.Serialize(writer, "cG105");
                    return;
                case ConnectorEnumType.CTesla:
                    serializer.Serialize(writer, "cTesla");
                    return;
                case ConnectorEnumType.CType1:
                    serializer.Serialize(writer, "cType1");
                    return;
                case ConnectorEnumType.CType2:
                    serializer.Serialize(writer, "cType2");
                    return;
                case ConnectorEnumType.S3091P16A:
                    serializer.Serialize(writer, "s309-1P-16A");
                    return;
                case ConnectorEnumType.S3091P32A:
                    serializer.Serialize(writer, "s309-1P-32A");
                    return;
                case ConnectorEnumType.S3093P16A:
                    serializer.Serialize(writer, "s309-3P-16A");
                    return;
                case ConnectorEnumType.S3093P32A:
                    serializer.Serialize(writer, "s309-3P-32A");
                    return;
                case ConnectorEnumType.SBs1361:
                    serializer.Serialize(writer, "sBS1361");
                    return;
                case ConnectorEnumType.SCee77:
                    serializer.Serialize(writer, "sCEE-7-7");
                    return;
                case ConnectorEnumType.SType2:
                    serializer.Serialize(writer, "sType2");
                    return;
                case ConnectorEnumType.SType3:
                    serializer.Serialize(writer, "sType3");
                    return;
                case ConnectorEnumType.WInductive:
                    serializer.Serialize(writer, "wInductive");
                    return;
                case ConnectorEnumType.WResonant:
                    serializer.Serialize(writer, "wResonant");
                    return;
            }
            throw new Exception("Cannot marshal type ConnectorEnumType");
        }

        public static readonly ConnectorEnumTypeConverter Singleton = new ConnectorEnumTypeConverter();
    }

    internal class PurpleMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length <= 255)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length <= 255)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly PurpleMinMaxLengthCheckConverter Singleton = new PurpleMinMaxLengthCheckConverter();
    }

    internal class FluffyMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length <= 36)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length <= 36)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly FluffyMinMaxLengthCheckConverter Singleton = new FluffyMinMaxLengthCheckConverter();
    }

    internal class TentacledMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length <= 50)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length <= 50)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly TentacledMinMaxLengthCheckConverter Singleton = new TentacledMinMaxLengthCheckConverter();
    }

    internal class IdTokenEnumTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(IdTokenEnumType) || t == typeof(IdTokenEnumType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Central":
                    return IdTokenEnumType.Central;
                case "ISO14443":
                    return IdTokenEnumType.Iso14443;
                case "ISO15693":
                    return IdTokenEnumType.Iso15693;
                case "KeyCode":
                    return IdTokenEnumType.KeyCode;
                case "Local":
                    return IdTokenEnumType.Local;
                case "MacAddress":
                    return IdTokenEnumType.MacAddress;
                case "NoAuthorization":
                    return IdTokenEnumType.NoAuthorization;
                case "eMAID":
                    return IdTokenEnumType.EMaid;
            }
            throw new Exception("Cannot unmarshal type IdTokenEnumType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (IdTokenEnumType)untypedValue;
            switch (value)
            {
                case IdTokenEnumType.Central:
                    serializer.Serialize(writer, "Central");
                    return;
                case IdTokenEnumType.Iso14443:
                    serializer.Serialize(writer, "ISO14443");
                    return;
                case IdTokenEnumType.Iso15693:
                    serializer.Serialize(writer, "ISO15693");
                    return;
                case IdTokenEnumType.KeyCode:
                    serializer.Serialize(writer, "KeyCode");
                    return;
                case IdTokenEnumType.Local:
                    serializer.Serialize(writer, "Local");
                    return;
                case IdTokenEnumType.MacAddress:
                    serializer.Serialize(writer, "MacAddress");
                    return;
                case IdTokenEnumType.NoAuthorization:
                    serializer.Serialize(writer, "NoAuthorization");
                    return;
                case IdTokenEnumType.EMaid:
                    serializer.Serialize(writer, "eMAID");
                    return;
            }
            throw new Exception("Cannot marshal type IdTokenEnumType");
        }

        public static readonly IdTokenEnumTypeConverter Singleton = new IdTokenEnumTypeConverter();
    }
}
