// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using Ocpp._201.Generated.Models.SetNetworkProfileRequest;
//
//    var setNetworkProfileRequest = SetNetworkProfileRequest.FromJson(jsonString);

namespace Ocpp._201.Generated.Models.SetNetworkProfileRequest
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class SetNetworkProfileRequest
    {
        /// <summary>
        /// Slot in which the configuration should be stored.
        /// </summary>
        [JsonProperty("configurationSlot")]
        public virtual long ConfigurationSlot { get; set; }

        [JsonProperty("connectionData")]
        public virtual NetworkConnectionProfileType ConnectionData { get; set; }

        [JsonProperty("customData", NullValueHandling = NullValueHandling.Ignore)]
        public virtual CustomDataType CustomData { get; set; }
    }

    /// <summary>
    /// Communication_ Function
    /// urn:x-oca:ocpp:uid:2:233304
    /// The NetworkConnectionProfile defines the functional and technical parameters of a
    /// communication link.
    /// </summary>
    public partial class NetworkConnectionProfileType
    {
        [JsonProperty("apn", NullValueHandling = NullValueHandling.Ignore)]
        public virtual ApnType Apn { get; set; }

        [JsonProperty("customData", NullValueHandling = NullValueHandling.Ignore)]
        public virtual CustomDataType CustomData { get; set; }

        /// <summary>
        /// Duration in seconds before a message send by the Charging Station via this network
        /// connection times-out.
        /// The best setting depends on the underlying network and response times of the CSMS.
        /// If you are looking for a some guideline: use 30 seconds as a starting point.
        /// </summary>
        [JsonProperty("messageTimeout")]
        public virtual long MessageTimeout { get; set; }

        /// <summary>
        /// Communication_ Function. OCPP_ Central_ System_ URL. URI
        /// urn:x-oca:ocpp:uid:1:569357
        /// URL of the CSMS(s) that this Charging Station  communicates with.
        /// </summary>
        [JsonProperty("ocppCsmsUrl")]
        [JsonConverter(typeof(PurpleMinMaxLengthCheckConverter))]
        public virtual string OcppCsmsUrl { get; set; }

        [JsonProperty("ocppInterface")]
        public virtual OcppInterfaceEnumType OcppInterface { get; set; }

        [JsonProperty("ocppTransport")]
        public virtual OcppTransportEnumType OcppTransport { get; set; }

        [JsonProperty("ocppVersion")]
        public virtual OcppVersionEnumType OcppVersion { get; set; }

        /// <summary>
        /// This field specifies the security profile used when connecting to the CSMS with this
        /// NetworkConnectionProfile.
        /// </summary>
        [JsonProperty("securityProfile")]
        public virtual long SecurityProfile { get; set; }

        [JsonProperty("vpn", NullValueHandling = NullValueHandling.Ignore)]
        public virtual VpnType Vpn { get; set; }
    }

    /// <summary>
    /// APN
    /// urn:x-oca:ocpp:uid:2:233134
    /// Collection of configuration data needed to make a data-connection over a cellular
    /// network.
    ///
    /// NOTE: When asking a GSM modem to dial in, it is possible to specify which mobile operator
    /// should be used. This can be done with the mobile country code (MCC) in combination with a
    /// mobile network code (MNC). Example: If your preferred network is Vodafone Netherlands,
    /// the MCC=204 and the MNC=04 which means the key PreferredNetwork = 20404 Some modems
    /// allows to specify a preferred network, which means, if this network is not available, a
    /// different network is used. If you specify UseOnlyPreferredNetwork and this network is not
    /// available, the modem will not dial in.
    /// </summary>
    public partial class ApnType
    {
        /// <summary>
        /// APN. APN. URI
        /// urn:x-oca:ocpp:uid:1:568814
        /// The Access Point Name as an URL.
        /// </summary>
        [JsonProperty("apn")]
        [JsonConverter(typeof(PurpleMinMaxLengthCheckConverter))]
        public virtual string Apn { get; set; }

        [JsonProperty("apnAuthentication")]
        public virtual ApnAuthenticationEnumType ApnAuthentication { get; set; }

        /// <summary>
        /// APN. APN. Password
        /// urn:x-oca:ocpp:uid:1:568819
        /// APN Password.
        /// </summary>
        [JsonProperty("apnPassword", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(FluffyMinMaxLengthCheckConverter))]
        public virtual string ApnPassword { get; set; }

        /// <summary>
        /// APN. APN. User_ Name
        /// urn:x-oca:ocpp:uid:1:568818
        /// APN username.
        /// </summary>
        [JsonProperty("apnUserName", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(FluffyMinMaxLengthCheckConverter))]
        public virtual string ApnUserName { get; set; }

        [JsonProperty("customData", NullValueHandling = NullValueHandling.Ignore)]
        public virtual CustomDataType CustomData { get; set; }

        /// <summary>
        /// APN. Preferred_ Network. Mobile_ Network_ ID
        /// urn:x-oca:ocpp:uid:1:568822
        /// Preferred network, written as MCC and MNC concatenated. See note.
        /// </summary>
        [JsonProperty("preferredNetwork", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(StickyMinMaxLengthCheckConverter))]
        public virtual string PreferredNetwork { get; set; }

        /// <summary>
        /// APN. SIMPIN. PIN_ Code
        /// urn:x-oca:ocpp:uid:1:568821
        /// SIM card pin code.
        /// </summary>
        [JsonProperty("simPin", NullValueHandling = NullValueHandling.Ignore)]
        public virtual long? SimPin { get; set; }

        /// <summary>
        /// APN. Use_ Only_ Preferred_ Network. Indicator
        /// urn:x-oca:ocpp:uid:1:568824
        /// Default: false. Use only the preferred Network, do
        /// not dial in when not available. See Note.
        /// </summary>
        [JsonProperty("useOnlyPreferredNetwork", NullValueHandling = NullValueHandling.Ignore)]
        public virtual bool? UseOnlyPreferredNetwork { get; set; }
    }

    /// <summary>
    /// This class does not get 'AdditionalProperties = false' in the schema generation, so it
    /// can be extended with arbitrary JSON properties to allow adding custom data.
    /// </summary>
    public partial class CustomDataType
    {
        [JsonProperty("vendorId")]
        [JsonConverter(typeof(TentacledMinMaxLengthCheckConverter))]
        public virtual string VendorId { get; set; }
    }

    /// <summary>
    /// VPN
    /// urn:x-oca:ocpp:uid:2:233268
    /// VPN Configuration settings
    /// </summary>
    public partial class VpnType
    {
        [JsonProperty("customData", NullValueHandling = NullValueHandling.Ignore)]
        public virtual CustomDataType CustomData { get; set; }

        /// <summary>
        /// VPN. Group. Group_ Name
        /// urn:x-oca:ocpp:uid:1:569274
        /// VPN group.
        /// </summary>
        [JsonProperty("group", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(FluffyMinMaxLengthCheckConverter))]
        public virtual string Group { get; set; }

        /// <summary>
        /// VPN. Key. VPN_ Key
        /// urn:x-oca:ocpp:uid:1:569276
        /// VPN shared secret.
        /// </summary>
        [JsonProperty("key")]
        [JsonConverter(typeof(TentacledMinMaxLengthCheckConverter))]
        public virtual string Key { get; set; }

        /// <summary>
        /// VPN. Password. Password
        /// urn:x-oca:ocpp:uid:1:569275
        /// VPN Password.
        /// </summary>
        [JsonProperty("password")]
        [JsonConverter(typeof(FluffyMinMaxLengthCheckConverter))]
        public virtual string Password { get; set; }

        /// <summary>
        /// VPN. Server. URI
        /// urn:x-oca:ocpp:uid:1:569272
        /// VPN Server Address
        /// </summary>
        [JsonProperty("server")]
        [JsonConverter(typeof(PurpleMinMaxLengthCheckConverter))]
        public virtual string Server { get; set; }

        [JsonProperty("type")]
        public virtual VpnEnumType Type { get; set; }

        /// <summary>
        /// VPN. User. User_ Name
        /// urn:x-oca:ocpp:uid:1:569273
        /// VPN User
        /// </summary>
        [JsonProperty("user")]
        [JsonConverter(typeof(FluffyMinMaxLengthCheckConverter))]
        public virtual string User { get; set; }
    }

    /// <summary>
    /// APN. APN_ Authentication. APN_ Authentication_ Code
    /// urn:x-oca:ocpp:uid:1:568828
    /// Authentication method.
    /// </summary>
    public enum ApnAuthenticationEnumType { Auto, Chap, None, Pap };

    /// <summary>
    /// Applicable Network Interface.
    /// </summary>
    public enum OcppInterfaceEnumType { Wired0, Wired1, Wired2, Wired3, Wireless0, Wireless1, Wireless2, Wireless3 };

    /// <summary>
    /// Communication_ Function. OCPP_ Transport. OCPP_ Transport_ Code
    /// urn:x-oca:ocpp:uid:1:569356
    /// Defines the transport protocol (e.g. SOAP or JSON). Note: SOAP is not supported in OCPP
    /// 2.0, but is supported by other versions of OCPP.
    /// </summary>
    public enum OcppTransportEnumType { Json, Soap };

    /// <summary>
    /// Communication_ Function. OCPP_ Version. OCPP_ Version_ Code
    /// urn:x-oca:ocpp:uid:1:569355
    /// Defines the OCPP version used for this communication function.
    /// </summary>
    public enum OcppVersionEnumType { Ocpp12, Ocpp15, Ocpp16, Ocpp20 };

    /// <summary>
    /// VPN. Type. VPN_ Code
    /// urn:x-oca:ocpp:uid:1:569277
    /// Type of VPN
    /// </summary>
    public enum VpnEnumType { IkEv2, IpSec, L2Tp, Pptp };

    public partial class SetNetworkProfileRequest
    {
        public static SetNetworkProfileRequest FromJson(string json) => JsonConvert.DeserializeObject<SetNetworkProfileRequest>(json, Ocpp._201.Generated.Models.SetNetworkProfileRequest.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this SetNetworkProfileRequest self) => JsonConvert.SerializeObject(self, Ocpp._201.Generated.Models.SetNetworkProfileRequest.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                ApnAuthenticationEnumTypeConverter.Singleton,
                OcppInterfaceEnumTypeConverter.Singleton,
                OcppTransportEnumTypeConverter.Singleton,
                OcppVersionEnumTypeConverter.Singleton,
                VpnEnumTypeConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class PurpleMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length <= 512)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length <= 512)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly PurpleMinMaxLengthCheckConverter Singleton = new PurpleMinMaxLengthCheckConverter();
    }

    internal class ApnAuthenticationEnumTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ApnAuthenticationEnumType) || t == typeof(ApnAuthenticationEnumType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "AUTO":
                    return ApnAuthenticationEnumType.Auto;
                case "CHAP":
                    return ApnAuthenticationEnumType.Chap;
                case "NONE":
                    return ApnAuthenticationEnumType.None;
                case "PAP":
                    return ApnAuthenticationEnumType.Pap;
            }
            throw new Exception("Cannot unmarshal type ApnAuthenticationEnumType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ApnAuthenticationEnumType)untypedValue;
            switch (value)
            {
                case ApnAuthenticationEnumType.Auto:
                    serializer.Serialize(writer, "AUTO");
                    return;
                case ApnAuthenticationEnumType.Chap:
                    serializer.Serialize(writer, "CHAP");
                    return;
                case ApnAuthenticationEnumType.None:
                    serializer.Serialize(writer, "NONE");
                    return;
                case ApnAuthenticationEnumType.Pap:
                    serializer.Serialize(writer, "PAP");
                    return;
            }
            throw new Exception("Cannot marshal type ApnAuthenticationEnumType");
        }

        public static readonly ApnAuthenticationEnumTypeConverter Singleton = new ApnAuthenticationEnumTypeConverter();
    }

    internal class FluffyMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length <= 20)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length <= 20)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly FluffyMinMaxLengthCheckConverter Singleton = new FluffyMinMaxLengthCheckConverter();
    }

    internal class TentacledMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length <= 255)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length <= 255)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly TentacledMinMaxLengthCheckConverter Singleton = new TentacledMinMaxLengthCheckConverter();
    }

    internal class StickyMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length <= 6)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length <= 6)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly StickyMinMaxLengthCheckConverter Singleton = new StickyMinMaxLengthCheckConverter();
    }

    internal class OcppInterfaceEnumTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(OcppInterfaceEnumType) || t == typeof(OcppInterfaceEnumType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Wired0":
                    return OcppInterfaceEnumType.Wired0;
                case "Wired1":
                    return OcppInterfaceEnumType.Wired1;
                case "Wired2":
                    return OcppInterfaceEnumType.Wired2;
                case "Wired3":
                    return OcppInterfaceEnumType.Wired3;
                case "Wireless0":
                    return OcppInterfaceEnumType.Wireless0;
                case "Wireless1":
                    return OcppInterfaceEnumType.Wireless1;
                case "Wireless2":
                    return OcppInterfaceEnumType.Wireless2;
                case "Wireless3":
                    return OcppInterfaceEnumType.Wireless3;
            }
            throw new Exception("Cannot unmarshal type OcppInterfaceEnumType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (OcppInterfaceEnumType)untypedValue;
            switch (value)
            {
                case OcppInterfaceEnumType.Wired0:
                    serializer.Serialize(writer, "Wired0");
                    return;
                case OcppInterfaceEnumType.Wired1:
                    serializer.Serialize(writer, "Wired1");
                    return;
                case OcppInterfaceEnumType.Wired2:
                    serializer.Serialize(writer, "Wired2");
                    return;
                case OcppInterfaceEnumType.Wired3:
                    serializer.Serialize(writer, "Wired3");
                    return;
                case OcppInterfaceEnumType.Wireless0:
                    serializer.Serialize(writer, "Wireless0");
                    return;
                case OcppInterfaceEnumType.Wireless1:
                    serializer.Serialize(writer, "Wireless1");
                    return;
                case OcppInterfaceEnumType.Wireless2:
                    serializer.Serialize(writer, "Wireless2");
                    return;
                case OcppInterfaceEnumType.Wireless3:
                    serializer.Serialize(writer, "Wireless3");
                    return;
            }
            throw new Exception("Cannot marshal type OcppInterfaceEnumType");
        }

        public static readonly OcppInterfaceEnumTypeConverter Singleton = new OcppInterfaceEnumTypeConverter();
    }

    internal class OcppTransportEnumTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(OcppTransportEnumType) || t == typeof(OcppTransportEnumType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "JSON":
                    return OcppTransportEnumType.Json;
                case "SOAP":
                    return OcppTransportEnumType.Soap;
            }
            throw new Exception("Cannot unmarshal type OcppTransportEnumType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (OcppTransportEnumType)untypedValue;
            switch (value)
            {
                case OcppTransportEnumType.Json:
                    serializer.Serialize(writer, "JSON");
                    return;
                case OcppTransportEnumType.Soap:
                    serializer.Serialize(writer, "SOAP");
                    return;
            }
            throw new Exception("Cannot marshal type OcppTransportEnumType");
        }

        public static readonly OcppTransportEnumTypeConverter Singleton = new OcppTransportEnumTypeConverter();
    }

    internal class OcppVersionEnumTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(OcppVersionEnumType) || t == typeof(OcppVersionEnumType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "OCPP12":
                    return OcppVersionEnumType.Ocpp12;
                case "OCPP15":
                    return OcppVersionEnumType.Ocpp15;
                case "OCPP16":
                    return OcppVersionEnumType.Ocpp16;
                case "OCPP20":
                    return OcppVersionEnumType.Ocpp20;
            }
            throw new Exception("Cannot unmarshal type OcppVersionEnumType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (OcppVersionEnumType)untypedValue;
            switch (value)
            {
                case OcppVersionEnumType.Ocpp12:
                    serializer.Serialize(writer, "OCPP12");
                    return;
                case OcppVersionEnumType.Ocpp15:
                    serializer.Serialize(writer, "OCPP15");
                    return;
                case OcppVersionEnumType.Ocpp16:
                    serializer.Serialize(writer, "OCPP16");
                    return;
                case OcppVersionEnumType.Ocpp20:
                    serializer.Serialize(writer, "OCPP20");
                    return;
            }
            throw new Exception("Cannot marshal type OcppVersionEnumType");
        }

        public static readonly OcppVersionEnumTypeConverter Singleton = new OcppVersionEnumTypeConverter();
    }

    internal class VpnEnumTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(VpnEnumType) || t == typeof(VpnEnumType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "IKEv2":
                    return VpnEnumType.IkEv2;
                case "IPSec":
                    return VpnEnumType.IpSec;
                case "L2TP":
                    return VpnEnumType.L2Tp;
                case "PPTP":
                    return VpnEnumType.Pptp;
            }
            throw new Exception("Cannot unmarshal type VpnEnumType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (VpnEnumType)untypedValue;
            switch (value)
            {
                case VpnEnumType.IkEv2:
                    serializer.Serialize(writer, "IKEv2");
                    return;
                case VpnEnumType.IpSec:
                    serializer.Serialize(writer, "IPSec");
                    return;
                case VpnEnumType.L2Tp:
                    serializer.Serialize(writer, "L2TP");
                    return;
                case VpnEnumType.Pptp:
                    serializer.Serialize(writer, "PPTP");
                    return;
            }
            throw new Exception("Cannot marshal type VpnEnumType");
        }

        public static readonly VpnEnumTypeConverter Singleton = new VpnEnumTypeConverter();
    }
}
