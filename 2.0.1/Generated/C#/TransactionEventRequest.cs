// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using Ocpp._201.Generated.Models.TransactionEventRequest;
//
//    var transactionEventRequest = TransactionEventRequest.FromJson(jsonString);

namespace Ocpp._201.Generated.Models.TransactionEventRequest
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class TransactionEventRequest
    {
        /// <summary>
        /// The maximum current of the connected cable in Ampere (A).
        /// </summary>
        [JsonProperty("cableMaxCurrent", NullValueHandling = NullValueHandling.Ignore)]
        public virtual long? CableMaxCurrent { get; set; }

        [JsonProperty("customData", NullValueHandling = NullValueHandling.Ignore)]
        public virtual CustomDataType CustomData { get; set; }

        [JsonProperty("eventType")]
        public virtual TransactionEventEnumType EventType { get; set; }

        [JsonProperty("evse", NullValueHandling = NullValueHandling.Ignore)]
        public virtual EvseType Evse { get; set; }

        [JsonProperty("idToken", NullValueHandling = NullValueHandling.Ignore)]
        public virtual IdTokenType IdToken { get; set; }

        [JsonProperty("meterValue", NullValueHandling = NullValueHandling.Ignore)]
        public virtual System.Collections.Generic.List<MeterValueType> MeterValue { get; set; }

        /// <summary>
        /// If the Charging Station is able to report the number of phases used, then it SHALL
        /// provide it. When omitted the CSMS may be able to determine the number of phases used via
        /// device management.
        /// </summary>
        [JsonProperty("numberOfPhasesUsed", NullValueHandling = NullValueHandling.Ignore)]
        public virtual long? NumberOfPhasesUsed { get; set; }

        /// <summary>
        /// Indication that this transaction event happened when the Charging Station was offline.
        /// Default = false, meaning: the event occurred when the Charging Station was online.
        /// </summary>
        [JsonProperty("offline", NullValueHandling = NullValueHandling.Ignore)]
        public virtual bool? Offline { get; set; }

        /// <summary>
        /// This contains the Id of the reservation that terminates as a result of this transaction.
        /// </summary>
        [JsonProperty("reservationId", NullValueHandling = NullValueHandling.Ignore)]
        public virtual long? ReservationId { get; set; }

        /// <summary>
        /// Incremental sequence number, helps with determining if all messages of a transaction have
        /// been received.
        /// </summary>
        [JsonProperty("seqNo")]
        public virtual long SeqNo { get; set; }

        /// <summary>
        /// The date and time at which this transaction event occurred.
        /// </summary>
        [JsonProperty("timestamp")]
        public virtual DateTimeOffset Timestamp { get; set; }

        [JsonProperty("transactionInfo")]
        public virtual TransactionType TransactionInfo { get; set; }

        [JsonProperty("triggerReason")]
        public virtual TriggerReasonEnumType TriggerReason { get; set; }
    }

    /// <summary>
    /// This class does not get 'AdditionalProperties = false' in the schema generation, so it
    /// can be extended with arbitrary JSON properties to allow adding custom data.
    /// </summary>
    public partial class CustomDataType
    {
        [JsonProperty("vendorId")]
        [JsonConverter(typeof(PurpleMinMaxLengthCheckConverter))]
        public virtual string VendorId { get; set; }
    }

    /// <summary>
    /// EVSE
    /// urn:x-oca:ocpp:uid:2:233123
    /// Electric Vehicle Supply Equipment
    /// </summary>
    public partial class EvseType
    {
        /// <summary>
        /// An id to designate a specific connector (on an EVSE) by connector index number.
        /// </summary>
        [JsonProperty("connectorId", NullValueHandling = NullValueHandling.Ignore)]
        public virtual long? ConnectorId { get; set; }

        [JsonProperty("customData", NullValueHandling = NullValueHandling.Ignore)]
        public virtual CustomDataType CustomData { get; set; }

        /// <summary>
        /// Identified_ Object. MRID. Numeric_ Identifier
        /// urn:x-enexis:ecdm:uid:1:569198
        /// EVSE Identifier. This contains a number (&gt; 0) designating an EVSE of the Charging
        /// Station.
        /// </summary>
        [JsonProperty("id")]
        public virtual long Id { get; set; }
    }

    /// <summary>
    /// Contains a case insensitive identifier to use for the authorization and the type of
    /// authorization to support multiple forms of identifiers.
    /// </summary>
    public partial class IdTokenType
    {
        [JsonProperty("additionalInfo", NullValueHandling = NullValueHandling.Ignore)]
        public virtual System.Collections.Generic.List<AdditionalInfoType> AdditionalInfo { get; set; }

        [JsonProperty("customData", NullValueHandling = NullValueHandling.Ignore)]
        public virtual CustomDataType CustomData { get; set; }

        /// <summary>
        /// IdToken is case insensitive. Might hold the hidden id of an RFID tag, but can for example
        /// also contain a UUID.
        /// </summary>
        [JsonProperty("idToken")]
        [JsonConverter(typeof(FluffyMinMaxLengthCheckConverter))]
        public virtual string IdToken { get; set; }

        [JsonProperty("type")]
        public virtual IdTokenEnumType Type { get; set; }
    }

    /// <summary>
    /// Contains a case insensitive identifier to use for the authorization and the type of
    /// authorization to support multiple forms of identifiers.
    /// </summary>
    public partial class AdditionalInfoType
    {
        /// <summary>
        /// This field specifies the additional IdToken.
        /// </summary>
        [JsonProperty("additionalIdToken")]
        [JsonConverter(typeof(FluffyMinMaxLengthCheckConverter))]
        public virtual string AdditionalIdToken { get; set; }

        [JsonProperty("customData", NullValueHandling = NullValueHandling.Ignore)]
        public virtual CustomDataType CustomData { get; set; }

        /// <summary>
        /// This defines the type of the additionalIdToken. This is a custom type, so the
        /// implementation needs to be agreed upon by all involved parties.
        /// </summary>
        [JsonProperty("type")]
        [JsonConverter(typeof(TentacledMinMaxLengthCheckConverter))]
        public virtual string Type { get; set; }
    }

    /// <summary>
    /// Meter_ Value
    /// urn:x-oca:ocpp:uid:2:233265
    /// Collection of one or more sampled values in MeterValuesRequest and TransactionEvent. All
    /// sampled values in a MeterValue are sampled at the same point in time.
    /// </summary>
    public partial class MeterValueType
    {
        [JsonProperty("customData", NullValueHandling = NullValueHandling.Ignore)]
        public virtual CustomDataType CustomData { get; set; }

        [JsonProperty("sampledValue")]
        public virtual System.Collections.Generic.List<SampledValueType> SampledValue { get; set; }

        /// <summary>
        /// Meter_ Value. Timestamp. Date_ Time
        /// urn:x-oca:ocpp:uid:1:569259
        /// Timestamp for measured value(s).
        /// </summary>
        [JsonProperty("timestamp")]
        public virtual DateTimeOffset Timestamp { get; set; }
    }

    /// <summary>
    /// Sampled_ Value
    /// urn:x-oca:ocpp:uid:2:233266
    /// Single sampled value in MeterValues. Each value can be accompanied by optional fields.
    ///
    /// To save on mobile data usage, default values of all of the optional fields are such that.
    /// The value without any additional fields will be interpreted, as a register reading of
    /// active import energy in Wh (Watt-hour) units.
    /// </summary>
    public partial class SampledValueType
    {
        [JsonProperty("context", NullValueHandling = NullValueHandling.Ignore)]
        public virtual ReadingContextEnumType? Context { get; set; }

        [JsonProperty("customData", NullValueHandling = NullValueHandling.Ignore)]
        public virtual CustomDataType CustomData { get; set; }

        [JsonProperty("location", NullValueHandling = NullValueHandling.Ignore)]
        public virtual LocationEnumType? Location { get; set; }

        [JsonProperty("measurand", NullValueHandling = NullValueHandling.Ignore)]
        public virtual MeasurandEnumType? Measurand { get; set; }

        [JsonProperty("phase", NullValueHandling = NullValueHandling.Ignore)]
        public virtual PhaseEnumType? Phase { get; set; }

        [JsonProperty("signedMeterValue", NullValueHandling = NullValueHandling.Ignore)]
        public virtual SignedMeterValueType SignedMeterValue { get; set; }

        [JsonProperty("unitOfMeasure", NullValueHandling = NullValueHandling.Ignore)]
        public virtual UnitOfMeasureType UnitOfMeasure { get; set; }

        /// <summary>
        /// Sampled_ Value. Value. Measure
        /// urn:x-oca:ocpp:uid:1:569260
        /// Indicates the measured value.
        /// </summary>
        [JsonProperty("value")]
        public virtual double Value { get; set; }
    }

    /// <summary>
    /// Represent a signed version of the meter value.
    /// </summary>
    public partial class SignedMeterValueType
    {
        [JsonProperty("customData", NullValueHandling = NullValueHandling.Ignore)]
        public virtual CustomDataType CustomData { get; set; }

        /// <summary>
        /// Method used to encode the meter values before applying the digital signature algorithm.
        /// </summary>
        [JsonProperty("encodingMethod")]
        [JsonConverter(typeof(TentacledMinMaxLengthCheckConverter))]
        public virtual string EncodingMethod { get; set; }

        /// <summary>
        /// Base64 encoded, sending depends on configuration variable _PublicKeyWithSignedMeterValue_.
        /// </summary>
        [JsonProperty("publicKey")]
        [JsonConverter(typeof(StickyMinMaxLengthCheckConverter))]
        public virtual string PublicKey { get; set; }

        /// <summary>
        /// Base64 encoded, contains the signed data which might contain more then just the meter
        /// value. It can contain information like timestamps, reference to a customer etc.
        /// </summary>
        [JsonProperty("signedMeterData")]
        [JsonConverter(typeof(StickyMinMaxLengthCheckConverter))]
        public virtual string SignedMeterData { get; set; }

        /// <summary>
        /// Method used to create the digital signature.
        /// </summary>
        [JsonProperty("signingMethod")]
        [JsonConverter(typeof(TentacledMinMaxLengthCheckConverter))]
        public virtual string SigningMethod { get; set; }
    }

    /// <summary>
    /// Represents a UnitOfMeasure with a multiplier
    /// </summary>
    public partial class UnitOfMeasureType
    {
        [JsonProperty("customData", NullValueHandling = NullValueHandling.Ignore)]
        public virtual CustomDataType CustomData { get; set; }

        /// <summary>
        /// Multiplier, this value represents the exponent to base 10. I.e. multiplier 3 means 10
        /// raised to the 3rd power. Default is 0.
        /// </summary>
        [JsonProperty("multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public virtual long? Multiplier { get; set; }

        /// <summary>
        /// Unit of the value. Default = "Wh" if the (default) measurand is an "Energy" type.
        /// This field SHALL use a value from the list Standardized Units of Measurements in Part 2
        /// Appendices.
        /// If an applicable unit is available in that list, otherwise a "custom" unit might be used.
        /// </summary>
        [JsonProperty("unit", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(IndigoMinMaxLengthCheckConverter))]
        public virtual string Unit { get; set; }
    }

    /// <summary>
    /// Transaction
    /// urn:x-oca:ocpp:uid:2:233318
    /// </summary>
    public partial class TransactionType
    {
        [JsonProperty("chargingState", NullValueHandling = NullValueHandling.Ignore)]
        public virtual ChargingStateEnumType? ChargingState { get; set; }

        [JsonProperty("customData", NullValueHandling = NullValueHandling.Ignore)]
        public virtual CustomDataType CustomData { get; set; }

        /// <summary>
        /// The ID given to remote start request (&lt;&lt;requeststarttransactionrequest,
        /// RequestStartTransactionRequest&gt;&gt;. This enables to CSMS to match the started
        /// transaction to the given start request.
        /// </summary>
        [JsonProperty("remoteStartId", NullValueHandling = NullValueHandling.Ignore)]
        public virtual long? RemoteStartId { get; set; }

        [JsonProperty("stoppedReason", NullValueHandling = NullValueHandling.Ignore)]
        public virtual ReasonEnumType? StoppedReason { get; set; }

        /// <summary>
        /// Transaction. Time_ Spent_ Charging. Elapsed_ Time
        /// urn:x-oca:ocpp:uid:1:569415
        /// Contains the total time that energy flowed from EVSE to EV during the transaction (in
        /// seconds). Note that timeSpentCharging is smaller or equal to the duration of the
        /// transaction.
        /// </summary>
        [JsonProperty("timeSpentCharging", NullValueHandling = NullValueHandling.Ignore)]
        public virtual long? TimeSpentCharging { get; set; }

        /// <summary>
        /// This contains the Id of the transaction.
        /// </summary>
        [JsonProperty("transactionId")]
        [JsonConverter(typeof(FluffyMinMaxLengthCheckConverter))]
        public virtual string TransactionId { get; set; }
    }

    /// <summary>
    /// This contains the type of this event.
    /// The first TransactionEvent of a transaction SHALL contain: "Started" The last
    /// TransactionEvent of a transaction SHALL contain: "Ended" All others SHALL contain:
    /// "Updated"
    /// </summary>
    public enum TransactionEventEnumType { Ended, Started, Updated };

    /// <summary>
    /// Enumeration of possible idToken types.
    /// </summary>
    public enum IdTokenEnumType { Central, EMaid, Iso14443, Iso15693, KeyCode, Local, MacAddress, NoAuthorization };

    /// <summary>
    /// Sampled_ Value. Context. Reading_ Context_ Code
    /// urn:x-oca:ocpp:uid:1:569261
    /// Type of detail value: start, end or sample. Default = "Sample.Periodic"
    /// </summary>
    public enum ReadingContextEnumType { InterruptionBegin, InterruptionEnd, Other, SampleClock, SamplePeriodic, TransactionBegin, TransactionEnd, Trigger };

    /// <summary>
    /// Sampled_ Value. Location. Location_ Code
    /// urn:x-oca:ocpp:uid:1:569265
    /// Indicates where the measured value has been sampled. Default =  "Outlet"
    /// </summary>
    public enum LocationEnumType { Body, Cable, Ev, Inlet, Outlet };

    /// <summary>
    /// Sampled_ Value. Measurand. Measurand_ Code
    /// urn:x-oca:ocpp:uid:1:569263
    /// Type of measurement. Default = "Energy.Active.Import.Register"
    /// </summary>
    public enum MeasurandEnumType { CurrentExport, CurrentImport, CurrentOffered, EnergyActiveExportInterval, EnergyActiveExportRegister, EnergyActiveImportInterval, EnergyActiveImportRegister, EnergyActiveNet, EnergyApparentExport, EnergyApparentImport, EnergyApparentNet, EnergyReactiveExportInterval, EnergyReactiveExportRegister, EnergyReactiveImportInterval, EnergyReactiveImportRegister, EnergyReactiveNet, Frequency, PowerActiveExport, PowerActiveImport, PowerFactor, PowerOffered, PowerReactiveExport, PowerReactiveImport, SoC, Voltage };

    /// <summary>
    /// Sampled_ Value. Phase. Phase_ Code
    /// urn:x-oca:ocpp:uid:1:569264
    /// Indicates how the measured value is to be interpreted. For instance between L1 and
    /// neutral (L1-N) Please note that not all values of phase are applicable to all Measurands.
    /// When phase is absent, the measured value is interpreted as an overall value.
    /// </summary>
    public enum PhaseEnumType { L1, L1L2, L1N, L2, L2L3, L2N, L3, L3L1, L3N, N };

    /// <summary>
    /// Transaction. State. Transaction_ State_ Code
    /// urn:x-oca:ocpp:uid:1:569419
    /// Current charging state, is required when state
    /// has changed.
    /// </summary>
    public enum ChargingStateEnumType { Charging, EvConnected, Idle, SuspendedEv, SuspendedEvse };

    /// <summary>
    /// Transaction. Stopped_ Reason. EOT_ Reason_ Code
    /// urn:x-oca:ocpp:uid:1:569413
    /// This contains the reason why the transaction was stopped. MAY only be omitted when Reason
    /// is "Local".
    /// </summary>
    public enum ReasonEnumType { DeAuthorized, EmergencyStop, EnergyLimitReached, EvDisconnected, GroundFault, ImmediateReset, Local, LocalOutOfCredit, MasterPass, Other, OvercurrentFault, PowerLoss, PowerQuality, Reboot, Remote, SocLimitReached, StoppedByEv, TimeLimitReached, Timeout };

    /// <summary>
    /// Reason the Charging Station sends this message to the CSMS
    /// </summary>
    public enum TriggerReasonEnumType { AbnormalCondition, Authorized, CablePluggedIn, ChargingRateChanged, ChargingStateChanged, Deauthorized, EnergyLimitReached, EvCommunicationLost, EvConnectTimeout, EvDeparted, EvDetected, MeterValueClock, MeterValuePeriodic, RemoteStart, RemoteStop, ResetCommand, SignedDataReceived, StopAuthorized, TimeLimitReached, Trigger, UnlockCommand };

    public partial class TransactionEventRequest
    {
        public static TransactionEventRequest FromJson(string json) => JsonConvert.DeserializeObject<TransactionEventRequest>(json, Ocpp._201.Generated.Models.TransactionEventRequest.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this TransactionEventRequest self) => JsonConvert.SerializeObject(self, Ocpp._201.Generated.Models.TransactionEventRequest.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                TransactionEventEnumTypeConverter.Singleton,
                IdTokenEnumTypeConverter.Singleton,
                ReadingContextEnumTypeConverter.Singleton,
                LocationEnumTypeConverter.Singleton,
                MeasurandEnumTypeConverter.Singleton,
                PhaseEnumTypeConverter.Singleton,
                ChargingStateEnumTypeConverter.Singleton,
                ReasonEnumTypeConverter.Singleton,
                TriggerReasonEnumTypeConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class PurpleMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length <= 255)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length <= 255)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly PurpleMinMaxLengthCheckConverter Singleton = new PurpleMinMaxLengthCheckConverter();
    }

    internal class TransactionEventEnumTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TransactionEventEnumType) || t == typeof(TransactionEventEnumType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Ended":
                    return TransactionEventEnumType.Ended;
                case "Started":
                    return TransactionEventEnumType.Started;
                case "Updated":
                    return TransactionEventEnumType.Updated;
            }
            throw new Exception("Cannot unmarshal type TransactionEventEnumType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TransactionEventEnumType)untypedValue;
            switch (value)
            {
                case TransactionEventEnumType.Ended:
                    serializer.Serialize(writer, "Ended");
                    return;
                case TransactionEventEnumType.Started:
                    serializer.Serialize(writer, "Started");
                    return;
                case TransactionEventEnumType.Updated:
                    serializer.Serialize(writer, "Updated");
                    return;
            }
            throw new Exception("Cannot marshal type TransactionEventEnumType");
        }

        public static readonly TransactionEventEnumTypeConverter Singleton = new TransactionEventEnumTypeConverter();
    }

    internal class FluffyMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length <= 36)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length <= 36)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly FluffyMinMaxLengthCheckConverter Singleton = new FluffyMinMaxLengthCheckConverter();
    }

    internal class TentacledMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length <= 50)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length <= 50)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly TentacledMinMaxLengthCheckConverter Singleton = new TentacledMinMaxLengthCheckConverter();
    }

    internal class IdTokenEnumTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(IdTokenEnumType) || t == typeof(IdTokenEnumType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Central":
                    return IdTokenEnumType.Central;
                case "ISO14443":
                    return IdTokenEnumType.Iso14443;
                case "ISO15693":
                    return IdTokenEnumType.Iso15693;
                case "KeyCode":
                    return IdTokenEnumType.KeyCode;
                case "Local":
                    return IdTokenEnumType.Local;
                case "MacAddress":
                    return IdTokenEnumType.MacAddress;
                case "NoAuthorization":
                    return IdTokenEnumType.NoAuthorization;
                case "eMAID":
                    return IdTokenEnumType.EMaid;
            }
            throw new Exception("Cannot unmarshal type IdTokenEnumType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (IdTokenEnumType)untypedValue;
            switch (value)
            {
                case IdTokenEnumType.Central:
                    serializer.Serialize(writer, "Central");
                    return;
                case IdTokenEnumType.Iso14443:
                    serializer.Serialize(writer, "ISO14443");
                    return;
                case IdTokenEnumType.Iso15693:
                    serializer.Serialize(writer, "ISO15693");
                    return;
                case IdTokenEnumType.KeyCode:
                    serializer.Serialize(writer, "KeyCode");
                    return;
                case IdTokenEnumType.Local:
                    serializer.Serialize(writer, "Local");
                    return;
                case IdTokenEnumType.MacAddress:
                    serializer.Serialize(writer, "MacAddress");
                    return;
                case IdTokenEnumType.NoAuthorization:
                    serializer.Serialize(writer, "NoAuthorization");
                    return;
                case IdTokenEnumType.EMaid:
                    serializer.Serialize(writer, "eMAID");
                    return;
            }
            throw new Exception("Cannot marshal type IdTokenEnumType");
        }

        public static readonly IdTokenEnumTypeConverter Singleton = new IdTokenEnumTypeConverter();
    }

    internal class ReadingContextEnumTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ReadingContextEnumType) || t == typeof(ReadingContextEnumType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Interruption.Begin":
                    return ReadingContextEnumType.InterruptionBegin;
                case "Interruption.End":
                    return ReadingContextEnumType.InterruptionEnd;
                case "Other":
                    return ReadingContextEnumType.Other;
                case "Sample.Clock":
                    return ReadingContextEnumType.SampleClock;
                case "Sample.Periodic":
                    return ReadingContextEnumType.SamplePeriodic;
                case "Transaction.Begin":
                    return ReadingContextEnumType.TransactionBegin;
                case "Transaction.End":
                    return ReadingContextEnumType.TransactionEnd;
                case "Trigger":
                    return ReadingContextEnumType.Trigger;
            }
            throw new Exception("Cannot unmarshal type ReadingContextEnumType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ReadingContextEnumType)untypedValue;
            switch (value)
            {
                case ReadingContextEnumType.InterruptionBegin:
                    serializer.Serialize(writer, "Interruption.Begin");
                    return;
                case ReadingContextEnumType.InterruptionEnd:
                    serializer.Serialize(writer, "Interruption.End");
                    return;
                case ReadingContextEnumType.Other:
                    serializer.Serialize(writer, "Other");
                    return;
                case ReadingContextEnumType.SampleClock:
                    serializer.Serialize(writer, "Sample.Clock");
                    return;
                case ReadingContextEnumType.SamplePeriodic:
                    serializer.Serialize(writer, "Sample.Periodic");
                    return;
                case ReadingContextEnumType.TransactionBegin:
                    serializer.Serialize(writer, "Transaction.Begin");
                    return;
                case ReadingContextEnumType.TransactionEnd:
                    serializer.Serialize(writer, "Transaction.End");
                    return;
                case ReadingContextEnumType.Trigger:
                    serializer.Serialize(writer, "Trigger");
                    return;
            }
            throw new Exception("Cannot marshal type ReadingContextEnumType");
        }

        public static readonly ReadingContextEnumTypeConverter Singleton = new ReadingContextEnumTypeConverter();
    }

    internal class LocationEnumTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(LocationEnumType) || t == typeof(LocationEnumType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Body":
                    return LocationEnumType.Body;
                case "Cable":
                    return LocationEnumType.Cable;
                case "EV":
                    return LocationEnumType.Ev;
                case "Inlet":
                    return LocationEnumType.Inlet;
                case "Outlet":
                    return LocationEnumType.Outlet;
            }
            throw new Exception("Cannot unmarshal type LocationEnumType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (LocationEnumType)untypedValue;
            switch (value)
            {
                case LocationEnumType.Body:
                    serializer.Serialize(writer, "Body");
                    return;
                case LocationEnumType.Cable:
                    serializer.Serialize(writer, "Cable");
                    return;
                case LocationEnumType.Ev:
                    serializer.Serialize(writer, "EV");
                    return;
                case LocationEnumType.Inlet:
                    serializer.Serialize(writer, "Inlet");
                    return;
                case LocationEnumType.Outlet:
                    serializer.Serialize(writer, "Outlet");
                    return;
            }
            throw new Exception("Cannot marshal type LocationEnumType");
        }

        public static readonly LocationEnumTypeConverter Singleton = new LocationEnumTypeConverter();
    }

    internal class MeasurandEnumTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(MeasurandEnumType) || t == typeof(MeasurandEnumType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Current.Export":
                    return MeasurandEnumType.CurrentExport;
                case "Current.Import":
                    return MeasurandEnumType.CurrentImport;
                case "Current.Offered":
                    return MeasurandEnumType.CurrentOffered;
                case "Energy.Active.Export.Interval":
                    return MeasurandEnumType.EnergyActiveExportInterval;
                case "Energy.Active.Export.Register":
                    return MeasurandEnumType.EnergyActiveExportRegister;
                case "Energy.Active.Import.Interval":
                    return MeasurandEnumType.EnergyActiveImportInterval;
                case "Energy.Active.Import.Register":
                    return MeasurandEnumType.EnergyActiveImportRegister;
                case "Energy.Active.Net":
                    return MeasurandEnumType.EnergyActiveNet;
                case "Energy.Apparent.Export":
                    return MeasurandEnumType.EnergyApparentExport;
                case "Energy.Apparent.Import":
                    return MeasurandEnumType.EnergyApparentImport;
                case "Energy.Apparent.Net":
                    return MeasurandEnumType.EnergyApparentNet;
                case "Energy.Reactive.Export.Interval":
                    return MeasurandEnumType.EnergyReactiveExportInterval;
                case "Energy.Reactive.Export.Register":
                    return MeasurandEnumType.EnergyReactiveExportRegister;
                case "Energy.Reactive.Import.Interval":
                    return MeasurandEnumType.EnergyReactiveImportInterval;
                case "Energy.Reactive.Import.Register":
                    return MeasurandEnumType.EnergyReactiveImportRegister;
                case "Energy.Reactive.Net":
                    return MeasurandEnumType.EnergyReactiveNet;
                case "Frequency":
                    return MeasurandEnumType.Frequency;
                case "Power.Active.Export":
                    return MeasurandEnumType.PowerActiveExport;
                case "Power.Active.Import":
                    return MeasurandEnumType.PowerActiveImport;
                case "Power.Factor":
                    return MeasurandEnumType.PowerFactor;
                case "Power.Offered":
                    return MeasurandEnumType.PowerOffered;
                case "Power.Reactive.Export":
                    return MeasurandEnumType.PowerReactiveExport;
                case "Power.Reactive.Import":
                    return MeasurandEnumType.PowerReactiveImport;
                case "SoC":
                    return MeasurandEnumType.SoC;
                case "Voltage":
                    return MeasurandEnumType.Voltage;
            }
            throw new Exception("Cannot unmarshal type MeasurandEnumType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (MeasurandEnumType)untypedValue;
            switch (value)
            {
                case MeasurandEnumType.CurrentExport:
                    serializer.Serialize(writer, "Current.Export");
                    return;
                case MeasurandEnumType.CurrentImport:
                    serializer.Serialize(writer, "Current.Import");
                    return;
                case MeasurandEnumType.CurrentOffered:
                    serializer.Serialize(writer, "Current.Offered");
                    return;
                case MeasurandEnumType.EnergyActiveExportInterval:
                    serializer.Serialize(writer, "Energy.Active.Export.Interval");
                    return;
                case MeasurandEnumType.EnergyActiveExportRegister:
                    serializer.Serialize(writer, "Energy.Active.Export.Register");
                    return;
                case MeasurandEnumType.EnergyActiveImportInterval:
                    serializer.Serialize(writer, "Energy.Active.Import.Interval");
                    return;
                case MeasurandEnumType.EnergyActiveImportRegister:
                    serializer.Serialize(writer, "Energy.Active.Import.Register");
                    return;
                case MeasurandEnumType.EnergyActiveNet:
                    serializer.Serialize(writer, "Energy.Active.Net");
                    return;
                case MeasurandEnumType.EnergyApparentExport:
                    serializer.Serialize(writer, "Energy.Apparent.Export");
                    return;
                case MeasurandEnumType.EnergyApparentImport:
                    serializer.Serialize(writer, "Energy.Apparent.Import");
                    return;
                case MeasurandEnumType.EnergyApparentNet:
                    serializer.Serialize(writer, "Energy.Apparent.Net");
                    return;
                case MeasurandEnumType.EnergyReactiveExportInterval:
                    serializer.Serialize(writer, "Energy.Reactive.Export.Interval");
                    return;
                case MeasurandEnumType.EnergyReactiveExportRegister:
                    serializer.Serialize(writer, "Energy.Reactive.Export.Register");
                    return;
                case MeasurandEnumType.EnergyReactiveImportInterval:
                    serializer.Serialize(writer, "Energy.Reactive.Import.Interval");
                    return;
                case MeasurandEnumType.EnergyReactiveImportRegister:
                    serializer.Serialize(writer, "Energy.Reactive.Import.Register");
                    return;
                case MeasurandEnumType.EnergyReactiveNet:
                    serializer.Serialize(writer, "Energy.Reactive.Net");
                    return;
                case MeasurandEnumType.Frequency:
                    serializer.Serialize(writer, "Frequency");
                    return;
                case MeasurandEnumType.PowerActiveExport:
                    serializer.Serialize(writer, "Power.Active.Export");
                    return;
                case MeasurandEnumType.PowerActiveImport:
                    serializer.Serialize(writer, "Power.Active.Import");
                    return;
                case MeasurandEnumType.PowerFactor:
                    serializer.Serialize(writer, "Power.Factor");
                    return;
                case MeasurandEnumType.PowerOffered:
                    serializer.Serialize(writer, "Power.Offered");
                    return;
                case MeasurandEnumType.PowerReactiveExport:
                    serializer.Serialize(writer, "Power.Reactive.Export");
                    return;
                case MeasurandEnumType.PowerReactiveImport:
                    serializer.Serialize(writer, "Power.Reactive.Import");
                    return;
                case MeasurandEnumType.SoC:
                    serializer.Serialize(writer, "SoC");
                    return;
                case MeasurandEnumType.Voltage:
                    serializer.Serialize(writer, "Voltage");
                    return;
            }
            throw new Exception("Cannot marshal type MeasurandEnumType");
        }

        public static readonly MeasurandEnumTypeConverter Singleton = new MeasurandEnumTypeConverter();
    }

    internal class PhaseEnumTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PhaseEnumType) || t == typeof(PhaseEnumType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "L1":
                    return PhaseEnumType.L1;
                case "L1-L2":
                    return PhaseEnumType.L1L2;
                case "L1-N":
                    return PhaseEnumType.L1N;
                case "L2":
                    return PhaseEnumType.L2;
                case "L2-L3":
                    return PhaseEnumType.L2L3;
                case "L2-N":
                    return PhaseEnumType.L2N;
                case "L3":
                    return PhaseEnumType.L3;
                case "L3-L1":
                    return PhaseEnumType.L3L1;
                case "L3-N":
                    return PhaseEnumType.L3N;
                case "N":
                    return PhaseEnumType.N;
            }
            throw new Exception("Cannot unmarshal type PhaseEnumType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PhaseEnumType)untypedValue;
            switch (value)
            {
                case PhaseEnumType.L1:
                    serializer.Serialize(writer, "L1");
                    return;
                case PhaseEnumType.L1L2:
                    serializer.Serialize(writer, "L1-L2");
                    return;
                case PhaseEnumType.L1N:
                    serializer.Serialize(writer, "L1-N");
                    return;
                case PhaseEnumType.L2:
                    serializer.Serialize(writer, "L2");
                    return;
                case PhaseEnumType.L2L3:
                    serializer.Serialize(writer, "L2-L3");
                    return;
                case PhaseEnumType.L2N:
                    serializer.Serialize(writer, "L2-N");
                    return;
                case PhaseEnumType.L3:
                    serializer.Serialize(writer, "L3");
                    return;
                case PhaseEnumType.L3L1:
                    serializer.Serialize(writer, "L3-L1");
                    return;
                case PhaseEnumType.L3N:
                    serializer.Serialize(writer, "L3-N");
                    return;
                case PhaseEnumType.N:
                    serializer.Serialize(writer, "N");
                    return;
            }
            throw new Exception("Cannot marshal type PhaseEnumType");
        }

        public static readonly PhaseEnumTypeConverter Singleton = new PhaseEnumTypeConverter();
    }

    internal class StickyMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length <= 2500)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length <= 2500)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly StickyMinMaxLengthCheckConverter Singleton = new StickyMinMaxLengthCheckConverter();
    }

    internal class IndigoMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length <= 20)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length <= 20)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly IndigoMinMaxLengthCheckConverter Singleton = new IndigoMinMaxLengthCheckConverter();
    }

    internal class ChargingStateEnumTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ChargingStateEnumType) || t == typeof(ChargingStateEnumType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Charging":
                    return ChargingStateEnumType.Charging;
                case "EVConnected":
                    return ChargingStateEnumType.EvConnected;
                case "Idle":
                    return ChargingStateEnumType.Idle;
                case "SuspendedEV":
                    return ChargingStateEnumType.SuspendedEv;
                case "SuspendedEVSE":
                    return ChargingStateEnumType.SuspendedEvse;
            }
            throw new Exception("Cannot unmarshal type ChargingStateEnumType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ChargingStateEnumType)untypedValue;
            switch (value)
            {
                case ChargingStateEnumType.Charging:
                    serializer.Serialize(writer, "Charging");
                    return;
                case ChargingStateEnumType.EvConnected:
                    serializer.Serialize(writer, "EVConnected");
                    return;
                case ChargingStateEnumType.Idle:
                    serializer.Serialize(writer, "Idle");
                    return;
                case ChargingStateEnumType.SuspendedEv:
                    serializer.Serialize(writer, "SuspendedEV");
                    return;
                case ChargingStateEnumType.SuspendedEvse:
                    serializer.Serialize(writer, "SuspendedEVSE");
                    return;
            }
            throw new Exception("Cannot marshal type ChargingStateEnumType");
        }

        public static readonly ChargingStateEnumTypeConverter Singleton = new ChargingStateEnumTypeConverter();
    }

    internal class ReasonEnumTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ReasonEnumType) || t == typeof(ReasonEnumType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "DeAuthorized":
                    return ReasonEnumType.DeAuthorized;
                case "EVDisconnected":
                    return ReasonEnumType.EvDisconnected;
                case "EmergencyStop":
                    return ReasonEnumType.EmergencyStop;
                case "EnergyLimitReached":
                    return ReasonEnumType.EnergyLimitReached;
                case "GroundFault":
                    return ReasonEnumType.GroundFault;
                case "ImmediateReset":
                    return ReasonEnumType.ImmediateReset;
                case "Local":
                    return ReasonEnumType.Local;
                case "LocalOutOfCredit":
                    return ReasonEnumType.LocalOutOfCredit;
                case "MasterPass":
                    return ReasonEnumType.MasterPass;
                case "Other":
                    return ReasonEnumType.Other;
                case "OvercurrentFault":
                    return ReasonEnumType.OvercurrentFault;
                case "PowerLoss":
                    return ReasonEnumType.PowerLoss;
                case "PowerQuality":
                    return ReasonEnumType.PowerQuality;
                case "Reboot":
                    return ReasonEnumType.Reboot;
                case "Remote":
                    return ReasonEnumType.Remote;
                case "SOCLimitReached":
                    return ReasonEnumType.SocLimitReached;
                case "StoppedByEV":
                    return ReasonEnumType.StoppedByEv;
                case "TimeLimitReached":
                    return ReasonEnumType.TimeLimitReached;
                case "Timeout":
                    return ReasonEnumType.Timeout;
            }
            throw new Exception("Cannot unmarshal type ReasonEnumType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ReasonEnumType)untypedValue;
            switch (value)
            {
                case ReasonEnumType.DeAuthorized:
                    serializer.Serialize(writer, "DeAuthorized");
                    return;
                case ReasonEnumType.EvDisconnected:
                    serializer.Serialize(writer, "EVDisconnected");
                    return;
                case ReasonEnumType.EmergencyStop:
                    serializer.Serialize(writer, "EmergencyStop");
                    return;
                case ReasonEnumType.EnergyLimitReached:
                    serializer.Serialize(writer, "EnergyLimitReached");
                    return;
                case ReasonEnumType.GroundFault:
                    serializer.Serialize(writer, "GroundFault");
                    return;
                case ReasonEnumType.ImmediateReset:
                    serializer.Serialize(writer, "ImmediateReset");
                    return;
                case ReasonEnumType.Local:
                    serializer.Serialize(writer, "Local");
                    return;
                case ReasonEnumType.LocalOutOfCredit:
                    serializer.Serialize(writer, "LocalOutOfCredit");
                    return;
                case ReasonEnumType.MasterPass:
                    serializer.Serialize(writer, "MasterPass");
                    return;
                case ReasonEnumType.Other:
                    serializer.Serialize(writer, "Other");
                    return;
                case ReasonEnumType.OvercurrentFault:
                    serializer.Serialize(writer, "OvercurrentFault");
                    return;
                case ReasonEnumType.PowerLoss:
                    serializer.Serialize(writer, "PowerLoss");
                    return;
                case ReasonEnumType.PowerQuality:
                    serializer.Serialize(writer, "PowerQuality");
                    return;
                case ReasonEnumType.Reboot:
                    serializer.Serialize(writer, "Reboot");
                    return;
                case ReasonEnumType.Remote:
                    serializer.Serialize(writer, "Remote");
                    return;
                case ReasonEnumType.SocLimitReached:
                    serializer.Serialize(writer, "SOCLimitReached");
                    return;
                case ReasonEnumType.StoppedByEv:
                    serializer.Serialize(writer, "StoppedByEV");
                    return;
                case ReasonEnumType.TimeLimitReached:
                    serializer.Serialize(writer, "TimeLimitReached");
                    return;
                case ReasonEnumType.Timeout:
                    serializer.Serialize(writer, "Timeout");
                    return;
            }
            throw new Exception("Cannot marshal type ReasonEnumType");
        }

        public static readonly ReasonEnumTypeConverter Singleton = new ReasonEnumTypeConverter();
    }

    internal class TriggerReasonEnumTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TriggerReasonEnumType) || t == typeof(TriggerReasonEnumType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "AbnormalCondition":
                    return TriggerReasonEnumType.AbnormalCondition;
                case "Authorized":
                    return TriggerReasonEnumType.Authorized;
                case "CablePluggedIn":
                    return TriggerReasonEnumType.CablePluggedIn;
                case "ChargingRateChanged":
                    return TriggerReasonEnumType.ChargingRateChanged;
                case "ChargingStateChanged":
                    return TriggerReasonEnumType.ChargingStateChanged;
                case "Deauthorized":
                    return TriggerReasonEnumType.Deauthorized;
                case "EVCommunicationLost":
                    return TriggerReasonEnumType.EvCommunicationLost;
                case "EVConnectTimeout":
                    return TriggerReasonEnumType.EvConnectTimeout;
                case "EVDeparted":
                    return TriggerReasonEnumType.EvDeparted;
                case "EVDetected":
                    return TriggerReasonEnumType.EvDetected;
                case "EnergyLimitReached":
                    return TriggerReasonEnumType.EnergyLimitReached;
                case "MeterValueClock":
                    return TriggerReasonEnumType.MeterValueClock;
                case "MeterValuePeriodic":
                    return TriggerReasonEnumType.MeterValuePeriodic;
                case "RemoteStart":
                    return TriggerReasonEnumType.RemoteStart;
                case "RemoteStop":
                    return TriggerReasonEnumType.RemoteStop;
                case "ResetCommand":
                    return TriggerReasonEnumType.ResetCommand;
                case "SignedDataReceived":
                    return TriggerReasonEnumType.SignedDataReceived;
                case "StopAuthorized":
                    return TriggerReasonEnumType.StopAuthorized;
                case "TimeLimitReached":
                    return TriggerReasonEnumType.TimeLimitReached;
                case "Trigger":
                    return TriggerReasonEnumType.Trigger;
                case "UnlockCommand":
                    return TriggerReasonEnumType.UnlockCommand;
            }
            throw new Exception("Cannot unmarshal type TriggerReasonEnumType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TriggerReasonEnumType)untypedValue;
            switch (value)
            {
                case TriggerReasonEnumType.AbnormalCondition:
                    serializer.Serialize(writer, "AbnormalCondition");
                    return;
                case TriggerReasonEnumType.Authorized:
                    serializer.Serialize(writer, "Authorized");
                    return;
                case TriggerReasonEnumType.CablePluggedIn:
                    serializer.Serialize(writer, "CablePluggedIn");
                    return;
                case TriggerReasonEnumType.ChargingRateChanged:
                    serializer.Serialize(writer, "ChargingRateChanged");
                    return;
                case TriggerReasonEnumType.ChargingStateChanged:
                    serializer.Serialize(writer, "ChargingStateChanged");
                    return;
                case TriggerReasonEnumType.Deauthorized:
                    serializer.Serialize(writer, "Deauthorized");
                    return;
                case TriggerReasonEnumType.EvCommunicationLost:
                    serializer.Serialize(writer, "EVCommunicationLost");
                    return;
                case TriggerReasonEnumType.EvConnectTimeout:
                    serializer.Serialize(writer, "EVConnectTimeout");
                    return;
                case TriggerReasonEnumType.EvDeparted:
                    serializer.Serialize(writer, "EVDeparted");
                    return;
                case TriggerReasonEnumType.EvDetected:
                    serializer.Serialize(writer, "EVDetected");
                    return;
                case TriggerReasonEnumType.EnergyLimitReached:
                    serializer.Serialize(writer, "EnergyLimitReached");
                    return;
                case TriggerReasonEnumType.MeterValueClock:
                    serializer.Serialize(writer, "MeterValueClock");
                    return;
                case TriggerReasonEnumType.MeterValuePeriodic:
                    serializer.Serialize(writer, "MeterValuePeriodic");
                    return;
                case TriggerReasonEnumType.RemoteStart:
                    serializer.Serialize(writer, "RemoteStart");
                    return;
                case TriggerReasonEnumType.RemoteStop:
                    serializer.Serialize(writer, "RemoteStop");
                    return;
                case TriggerReasonEnumType.ResetCommand:
                    serializer.Serialize(writer, "ResetCommand");
                    return;
                case TriggerReasonEnumType.SignedDataReceived:
                    serializer.Serialize(writer, "SignedDataReceived");
                    return;
                case TriggerReasonEnumType.StopAuthorized:
                    serializer.Serialize(writer, "StopAuthorized");
                    return;
                case TriggerReasonEnumType.TimeLimitReached:
                    serializer.Serialize(writer, "TimeLimitReached");
                    return;
                case TriggerReasonEnumType.Trigger:
                    serializer.Serialize(writer, "Trigger");
                    return;
                case TriggerReasonEnumType.UnlockCommand:
                    serializer.Serialize(writer, "UnlockCommand");
                    return;
            }
            throw new Exception("Cannot marshal type TriggerReasonEnumType");
        }

        public static readonly TriggerReasonEnumTypeConverter Singleton = new TriggerReasonEnumTypeConverter();
    }
}
